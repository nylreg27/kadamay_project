# apps/payment/views.py

from django.shortcuts import render, redirect, get_object_or_404
from django.urls import reverse
from django.contrib import messages
from django.contrib.auth.decorators import login_required, user_passes_test # Import user_passes_test
from django.db import transaction
from django.http import JsonResponse
import json
from django.views.decorators.http import require_http_methods
from django.utils import timezone # Import timezone for setting validation_date

from .forms import PaymentForm
from .models import Payment, Individual, ContributionType # Import necessary models
from apps.family.models import Family # Need to import Family for get_family_details_api_view

# Helper function to check if user is an admin or cashier (for validation)
# You might need to define what makes a user an 'admin' or 'cashier' in your system.
# For now, let's assume superusers are admins, or you can add a custom group/permission check.
def is_admin_or_cashier(user):
    # Example: User is superuser, or belongs to a 'Cashier' group
    return user.is_superuser # Or user.groups.filter(name='Cashiers').exists()

# Function-based view for payment creation
@login_required
def payment_create_full_form_view(request, individual_id=None):
    individual = None
    if individual_id:
        individual = get_object_or_404(Individual, pk=individual_id)

    if request.method == 'POST':
        form = PaymentForm(request.POST, instance=None) # Always create new instance for new payment
        if form.is_valid():
            payment = form.save(commit=False)
            payment._request_user = request.user # Pass the request user to the model's save method
            
            # Set 'collected_by' to the user creating the payment
            payment.collected_by = request.user 
            
            # === NEW LOGIC: DIRECT VALIDATION FOR ADMINS/CASHIERS ===
            if is_admin_or_cashier(request.user):
                payment.payment_status = 'VALIDATED'
                payment.validated_by = request.user
                payment.validation_date = timezone.now()
                messages.success(request, f"Payment record for {payment.individual.full_name} saved and directly validated!")
            else:
                # Payment status will default to 'PENDING_VALIDATION' as per Payment model's default value.
                # If not admin/cashier, it remains PENDING_VALIDATION by default.
                payment.payment_status = 'PENDING_VALIDATION' # Explicitly set for clarity
                messages.success(request, f"Payment record for {payment.individual.full_name} saved successfully and awaiting validation!")
            # === END NEW LOGIC ===

            # --- Handle selected_members_ids from hidden input ---
            selected_members_ids_json = request.POST.get('selected_members_ids', '[]')
            try:
                selected_members_ids = json.loads(selected_members_ids_json)
            except json.JSONDecodeError:
                selected_members_ids = []
            
            # Save the payment instance first to get a PK
            try:
                with transaction.atomic():
                    payment.save()
                    form.save_m2m() # Save M2M for covered_members if used later

                    # Logic to create PaymentIndividualAllocation instances
                    for member_id in selected_members_ids:
                        member = get_object_or_404(Individual, pk=member_id)
                        from .models import PaymentIndividualAllocation # Import here to avoid circular dependency
                        PaymentIndividualAllocation.objects.create(
                            payment=payment,
                            individual=member,
                            allocated_amount=payment.contribution_type.amount if payment.contribution_type else 0
                        )

                    # Redirect to individual dashboard
                    return redirect(reverse('individual:individual_dashboard')) 
            except Exception as e:
                messages.error(request, f"Error saving payment record: {e}")
                # Re-render form with errors if save fails
                context = {
                    'form': form,
                    'page_title': 'Add New Payment',
                    'individual': individual,
                }
                return render(request, 'payment/payment_form.html', context)
        else:
            messages.error(request, "Please correct the errors below.")
    else:
        # For GET requests, pre-fill individual if ID is provided
        initial_data = {}
        if individual:
            initial_data['individual'] = individual.pk
        
        form = PaymentForm(initial=initial_data)

    context = {
        'form': form,
        'page_title': 'Add New Payment',
        'individual': individual, # Pass individual object to template for display
    }
    return render(request, 'payment/payment_form.html', context)


# View to display a list of payments (basic placeholder)
@login_required
def payment_list_view(request):
    payments = Payment.objects.all().order_by('-date_paid', '-created_at')
    context = {
        'payments': payments,
        'page_title': 'All Payments'
    }
    return render(request, 'payment/payment_list.html', context) # Assuming you have a payment_list.html

# View to display single payment details (basic placeholder)
@login_required
def payment_detail_view(request, pk):
    payment = get_object_or_404(Payment, pk=pk)
    context = {
        'payment': payment,
        'page_title': f'Payment Details: {payment.receipt_number or "N/A"}'
    }
    # This template will be different from individual_dashboard.html
    return render(request, 'payment/payment_detail.html', context)


# === API endpoint for fetching family details (used by payment_form.html) ===
@require_http_methods(["GET"])
@login_required
def get_family_details_api_view(request, individual_id):
    try:
        individual = get_object_or_404(Individual, pk=individual_id)
        family_data = None
        family_members_list = []

        if individual.family:
            family = individual.family
            family_data = {
                'id': family.id,
                'family_name': family.family_name,
                # Add other family details as needed
            }
            # Fetch all members of the family (including the head)
            members = family.members.all().order_by('surname', 'given_name')
            for member in members:
                family_members_list.append({
                    'id': member.id,
                    'full_name': member.full_name,
                    'relationship': member.get_relationship_display_value(), # Use your property/method
                    'status': 'Active' if member.is_active_member and member.is_alive else 'Inactive'
                })

        return JsonResponse({
            'family_name': family_data['family_name'] if family_data else None,
            'family_members': family_members_list
        })
    except Individual.DoesNotExist:
        return JsonResponse({'error': 'Individual not found.'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)


# === API endpoint for fetching contribution type amount (used by payment_form.html) ===
@require_http_methods(["GET"])
@login_required
def get_contribution_amount_api_view(request, pk):
    try:
        contribution_type = get_object_or_404(ContributionType, pk=pk)
        return JsonResponse({'amount': contribution_type.amount})
    except ContributionType.DoesNotExist:
        return JsonResponse({'error': 'Contribution type not found.'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)


# === CANCELLATION VIEW ===
@login_required
def cancel_payment_view(request, pk):
    # Ensure it's a POST request for security
    if request.method == 'POST':
        payment = get_object_or_404(Payment, pk=pk)
        
        # Prevent cancelling already cancelled or legacy payments
        if payment.payment_status == 'CANCELLED' or payment.is_legacy_record:
            return JsonResponse({'error': 'This payment cannot be cancelled or is already cancelled/legacy.'}, status=400)

        try:
            # Get cancellation reason from the request body (JSON)
            data = json.loads(request.body)
            cancellation_reason = data.get('cancellation_reason', '').strip()

            if not cancellation_reason:
                return JsonResponse({'error': 'Cancellation reason is required.'}, status=400)
            
            with transaction.atomic():
                payment.is_cancelled = True
                payment.payment_status = 'CANCELLED' # Set status to CANCELLED
                payment.cancellation_reason = cancellation_reason
                payment.cancelled_by = request.user # The user who performed the cancellation
                payment.cancellation_date = timezone.now() # The time of cancellation
                payment.save(update_fields=['is_cancelled', 'payment_status', 'cancellation_reason', 'cancelled_by', 'cancellation_date'])
            
            messages.success(request, f"Payment (OR: {payment.receipt_number or 'N/A'}) has been successfully cancelled.")
            return JsonResponse({'message': 'Payment cancelled successfully.'})

        except json.JSONDecodeError:
            return JsonResponse({'error': 'Invalid JSON in request body.'}, status=400)
        except Exception as e:
            messages.error(request, f"Failed to cancel payment: {e}")
            return JsonResponse({'error': f'An error occurred: {e}'}, status=500)
    
    # If not a POST request, return Method Not Allowed
    return JsonResponse({'error': 'Method not allowed.'}, status=405)


# === NEW: View to list payments pending validation ===
@login_required
@user_passes_test(is_admin_or_cashier) # Only admins/cashiers can view this
def pending_payments_list_view(request):
    pending_payments = Payment.objects.filter(payment_status='PENDING_VALIDATION').order_by('-date_paid', '-created_at')
    context = {
        'pending_payments': pending_payments,
        'page_title': 'Payments Pending Validation'
    }
    return render(request, 'payment/pending_payments_list.html', context)


# === NEW: API endpoint to validate a payment ===
@require_http_methods(["POST"])
@login_required
@user_passes_test(is_admin_or_cashier) # Only admins/cashiers can perform validation
def validate_payment_view(request, pk):
    try:
        payment = get_object_or_404(Payment, pk=pk)

        # Check if the payment is actually pending validation
        if payment.payment_status != 'PENDING_VALIDATION':
            return JsonResponse({'error': 'Payment is not in pending validation status.'}, status=400)

        with transaction.atomic():
            payment.payment_status = 'VALIDATED'
            payment.validated_by = request.user
            payment.validation_date = timezone.now()
            payment.save(update_fields=['payment_status', 'validated_by', 'validation_date', 'updated_at']) # Save updated_at too

        messages.success(request, f"Payment (OR: {payment.receipt_number or 'N/A'}) has been successfully validated.")
        return JsonResponse({'message': 'Payment validated successfully.'})

    except Payment.DoesNotExist:
        return JsonResponse({'error': 'Payment not found.'}, status=404)
    except Exception as e:
        messages.error(request, f"Failed to validate payment: {e}")
        return JsonResponse({'error': f'An error occurred: {e}'}, status=500)
