# apps/individual/views.py

from django.shortcuts import render, get_object_or_404
from django.http import JsonResponse
from django.views.decorators.http import require_http_methods
from django.contrib.auth.decorators import login_required
from django.views.generic import TemplateView, ListView, DetailView, CreateView, UpdateView, DeleteView
from django.contrib.auth.mixins import LoginRequiredMixin
from django.urls import reverse_lazy
from django.db.models import Q, Sum, Max # <--- ADD Sum, Max IMPORTS!
from django.contrib import messages
from apps.payment.models import Payment # <--- Make sure this is imported correctly
from apps.individual.models import Individual
from apps.family.models import Family
from apps.church.models import Church
from .forms import IndividualForm # Assuming you have apps/individual/forms.py

# Your existing IndividualDashboardView
class IndividualDashboardView(LoginRequiredMixin, TemplateView):
    template_name = 'individual/individual_dashboard.html'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['title'] = 'Kadamay Dashboard'

        # Fetch individuals for the sidebar list
        context['individuals'] = Individual.objects.filter(
            is_active_member=True,
            is_alive=True
        ).order_by('surname', 'given_name')

        return context


@require_http_methods(["GET"])
@login_required
def individual_details_api(request, pk):
    try:
        individual = get_object_or_404(Individual, pk=pk)
        
        # --- FIXED: Fetch payment history for this individual as payer OR covered member ---
        # Filter payments where:
        # 1. The individual is the primary 'payer' of the payment (payment.individual)
        # OR
        # 2. The individual is listed as a 'covered_member' through PaymentIndividualAllocation
        all_payments = Payment.objects.filter(
            Q(individual=individual) | 
            Q(individual_allocations__individual=individual)
        ).distinct().order_by('-date_paid', '-created_at') # Use distinct to avoid duplicate payments if an individual is both payer and covered member on the same payment.

        payments_data = []
        for payment in all_payments:
            payments_data.append({
                'id': payment.id,
                'date': payment.date_paid.strftime('%Y-%m-%d'), # Format date
                'description': payment.contribution_type.name if payment.contribution_type else 'N/A',
                'amount': float(payment.amount), # Convert Decimal to float for JSON
                'receipt_number': payment.receipt_number if payment.receipt_number else 'N/A',
                'status': payment.payment_status, # Send raw status for badge logic
                'status_display': payment.get_payment_status_display(), # Send display for convenience
                'method_display': payment.get_payment_method_display(),
                'deceased_member_name': payment.deceased_member.full_name if payment.deceased_member else 'N/A',
                'is_cancelled': payment.is_cancelled, # Send cancellation flag
                'is_legacy_record': payment.is_legacy_record, # Send legacy flag
            })
        
        # --- Calculate financial summary ---
        # Exclude 'CANCELLED' payments from total contributions unless explicitly needed for audit report
        active_payments = all_payments.exclude(payment_status='CANCELLED')
        total_contributions = active_payments.aggregate(Sum('amount'))['amount__sum'] or 0.00
        latest_payment_date = active_payments.aggregate(Max('date_paid'))['date_paid__max']

        data = {
            'id': individual.id,
            'full_name': individual.full_name,
            'given_name': individual.given_name,
            'middle_name': individual.middle_name,
            'surname': individual.surname,
            'suffix_name': individual.suffix_name,
            'membership_id': individual.membership_id, # Corrected from 'code'
            'relationship': individual.relationship,
            'membership_status': individual.membership_status,
            'is_alive': individual.is_alive,
            'is_active_member': individual.is_active_member,
            'sex': individual.get_sex_display(), # Get display value
            'civil_status': individual.get_civil_status_display(), # Get display value
            'birth_date': individual.birth_date.strftime('%Y-%m-%d') if individual.birth_date else 'N/A',
            'contact_no': individual.contact_number or 'N/A', # Use contact_number
            'email_address': individual.email_address or 'N/A',
            'address': individual.address or 'N/A', # Assuming address is CharField
            'date_added': individual.date_added.strftime('%Y-%m-%d') if individual.date_added else 'N/A',
            
            # Family details (adjust based on your Family model structure)
            'family_id': individual.family.id if individual.family else None,
            'family_name': individual.family.family_name if individual.family else "N/A",
            'family_head_name': individual.family.head_of_family.full_name if individual.family and hasattr(individual.family, 'head_of_family') else "N/A",
            'other_family_members': [
                {'id': m.id, 'full_name': m.full_name, 'relationship': m.get_relationship_display_value()} 
                for m in individual.family.members.all() if m != individual
            ] if individual.family else [],

            # --- Financial Summary and Payments Data ---
            'total_contributions': total_contributions,
            'latest_payment_date': latest_payment_date.strftime('%Y-%m-%d') if latest_payment_date else 'N/A',
            'payments': payments_data, # Include the payment history
        }
        return JsonResponse(data)
    except Individual.DoesNotExist:
        return JsonResponse({'error': 'Individual not found'}, status=404)
    except Exception as e:
        print(f"Error in individual_details_api: {e}")
        return JsonResponse({'error': str(e)}, status=500)

# Individual List View - MODIFIED FOR SEARCH
class IndividualListView(LoginRequiredMixin, ListView):
    model = Individual
    template_name = 'individual/individual_list.html'
    context_object_name = 'individuals'
    paginate_by = 10

    def get_queryset(self):
        queryset = Individual.objects.filter(
            is_active_member=True, is_alive=True)
        search_query = self.request.GET.get('search')
        if search_query:
            queryset = queryset.filter(
                Q(surname__icontains=search_query) |
                Q(given_name__icontains=search_query) |
                Q(middle_name__icontains=search_query) |
                Q(suffix_name__icontains=search_query) |
                Q(membership_id__icontains=search_query) |
                Q(family__family_name__icontains=search_query) 
                # Q(family__church__name__icontains=search_query) # Uncomment if you have Church foreign key in Family
            )
        return queryset.order_by('surname', 'given_name')

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['title'] = 'Members'
        context['search_query'] = self.request.GET.get('search', '')
        return context

# Individual Detail View
class IndividualDetailView(LoginRequiredMixin, DetailView):
    model = Individual
    template_name = 'individual/individual_detail.html'
    context_object_name = 'individual'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['title'] = f'Individual Details - {self.object.full_name}'
        return context

# Individual Create View
class IndividualCreateView(LoginRequiredMixin, CreateView):
    model = Individual
    form_class = IndividualForm
    template_name = 'individual/individual_form.html'
    success_url = reverse_lazy('individual:individual_list')
    extra_context = {'title': 'Add New Individual'}

    def form_valid(self, form):
        if not form.cleaned_data.get('membership_status'):
            form.instance.membership_status = 'ACTIVE'
        messages.success(self.request, "Individual added successfully!")
        return super().form_valid(form)

    def form_invalid(self, form):
        print("\n--- IndividualCreateView FORM IS INVALID! ---")
        print("Field errors:", form.errors)
        print("Non-field errors:", form.non_field_errors)
        print("-------------------------------------\n")
        messages.error(self.request, "Please correct the errors below.")
        return super().form_invalid(form)


# Individual Update View
class IndividualUpdateView(LoginRequiredMixin, UpdateView):
    model = Individual
    form_class = IndividualForm
    template_name = 'individual/individual_form.html'
    success_url = reverse_lazy('individual:individual_list')
    extra_context = {'title': 'Edit Individual'}

    def form_valid(self, form):
        messages.success(self.request, "Individual updated successfully!")
        return super().form_valid(form)

    def form_invalid(self, form):
        print("\n--- IndividualUpdateView FORM IS INVALID! ---")
        print("Field errors:", form.errors)
        print("Non-field errors:", form.non_field_errors)
        print("-------------------------------------\n")
        messages.error(self.request, "Please correct the errors below.")
        return super().form_invalid(form)

# Individual Delete View
class IndividualDeleteView(LoginRequiredMixin, DeleteView):
    model = Individual
    template_name = 'individual/individual_confirm_delete.html'
    success_url = reverse_lazy('individual:individual_list')

    def form_valid(self, form):
        messages.success(self.request, "Individual deleted successfully!")
        return super().form_valid(form)

# URL for listing individuals within a specific church - MODIFIED FOR SEARCH
class IndividualListInChurchView(LoginRequiredMixin, ListView):
    model = Individual
    template_name = 'individual/individual_list.html'
    context_object_name = 'individuals'

    def get_queryset(self):
        church_id = self.kwargs['church_id']
        church = get_object_or_404(Church, id=church_id)

        queryset = Individual.objects.filter(
            family__church=church,
            is_active_member=True,
            is_alive=True
        )
        search_query = self.request.GET.get('search')
        if search_query:
            queryset = queryset.filter(
                Q(surname__icontains=search_query) |
                Q(given_name__icontains=search_query) |
                Q(middle_name__icontains=search_query) |
                Q(suffix_name__icontains=search_query) |
                Q(membership_id__icontains=search_query) |
                Q(family__family_name__icontains=search_query)
            )
        return queryset.order_by('surname', 'given_name')

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        church_id = self.kwargs['church_id']
        church = get_object_or_404(Church, id=church_id)
        context['title'] = f'Individuals in {church.name}'
        context['church'] = church
        context['search_query'] = self.request.GET.get(
            'search', '')
        return context

# NEW URL: For creating an individual within a specific family context
class IndividualCreateInFamilyView(LoginRequiredMixin, CreateView):
    model = Individual
    form_class = IndividualForm
    template_name = 'individual/individual_form.html'

    def get_initial(self):
        initial = super().get_initial()
        family_id = self.kwargs.get('family_id')
        if family_id:
            initial['family'] = get_object_or_404(Family, id=family_id)
        return initial

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        family_id = self.kwargs.get('family_id')
        if family_id:
            family = get_object_or_404(Family, id=family_id)
            context['title'] = f'Add Individual to {family.family_name}'
            context['family'] = family
        else:
            context['title'] = 'Add New Individual'
        return context

    def get_success_url(self):
        family_id = self.kwargs.get('family_id')
        if family_id:
            return reverse_lazy('family:family_detail', kwargs={'pk': family_id})
        return reverse_lazy('individual:individual_list')

    def form_valid(self, form):
        if not form.cleaned_data.get('membership_status'):
            form.instance.membership_status = 'ACTIVE'
        messages.success(self.request, "Individual added successfully!")
        return super().form_valid(form)

    def form_invalid(self, form):
        print("\n--- IndividualCreateInFamilyView FORM IS INVALID! ---")
        print("Field errors:", form.errors)
        print("Non-field errors:", form.non_field_errors)
        print("-------------------------------------\n")
        messages.error(self.request, "Please correct the errors below.")
        return super().form_invalid(form)

# COMMENTED OUT: This class was a duplicate from payment/views.py.
# All payment creation logic should be in apps/payment/views.py.
# class PaymentCreateView(LoginRequiredMixin, CreateView):
#     model = Payment
#     form_class = PaymentForm  # You'll need to define this in apps/payment/forms.py
#     template_name = 'payment/payment_form.html'  # Create this template

#     def get_initial(self):
#         initial = super().get_initial()
#         individual_id = self.kwargs.get('individual_id')
#         if individual_id:
#             initial['individual'] = get_object_or_404(
#                 Individual, pk=individual_id)
#         return initial

#     def get_context_data(self, **kwargs):
#         context = super().get_context_data(**kwargs)
#         individual_id = self.kwargs.get('individual_id')
#         if individual_id:
#             individual = get_object_or_404(Individual, pk=individual_id)
#             context['title'] = f'Add Payment for {individual.full_name}'
#             context['individual'] = individual
#         else:
#             context['title'] = 'Add New Payment'
#         return context

#     def form_valid(self, form):
#         messages.success(self.request, "Payment added successfully!")
#         return super().form_valid(form)

#     def get_success_url(self):
#         individual_id = self.kwargs.get('individual_id')
#         if individual_id:
#             return reverse_lazy('individual:individual_dashboard')
#         return reverse_lazy('individual:individual_list')
